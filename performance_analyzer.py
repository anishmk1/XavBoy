#!/usr/bin/env python3
"""
Performance Analyzer for XavBoy Game Boy Emulator

This script reads performance data from the CSV file generated by the emulator
and creates visualizations showing time spent in each component per frame.

Usage:
    python3 performance_analyzer.py [csv_file_path] [suffix]

If no path is provided, it defaults to 'logs/performance.csv'
If suffix is provided, it will be appended to output filenames (e.g., suffix "2" creates "performance_stacked-2.png")
"""

import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
import sys
import os
from pathlib import Path


def load_performance_data(csv_path):
    """Load performance data from CSV file."""
    try:
        df = pd.read_csv(csv_path)
        print(f"Loaded {len(df)} frame records from {csv_path}")
        return df
    except FileNotFoundError:
        print(f"Error: CSV file not found at {csv_path}")
        print("Make sure you've run the emulator with performance logging enabled.")
        return None
    except pd.errors.EmptyDataError:
        print(f"Error: CSV file {csv_path} is empty.")
        return None


def print_summary_statistics(df):
    """Print summary statistics for performance data."""
    print("\n=== Performance Summary Statistics ===")

    # Overall frame statistics
    total_frames = len(df)
    avg_total_time = df['total_frame_time_ms'].mean()
    fps_estimate = 1000.0 / avg_total_time if avg_total_time > 0 else 0

    print(f"Total frames analyzed: {total_frames}")
    print(f"Average frame time: {avg_total_time:.4f} ms")
    print(f"Estimated FPS: {fps_estimate:.2f}")

    # Component timing statistics
    components = ['cpu_time_ms', 'ppu_time_ms', 'mmio_time_ms', 'lcd_time_ms',
                  'sdl_events_time_ms', 'debugger_time_ms', 'interrupt_time_ms', 'other_time_ms']
    component_names = ['CPU', 'PPU', 'MMIO', 'LCD', 'SDL Events', 'Debugger', 'Interrupt', 'Other']

    print(f"\n{'Component':<8} {'Avg (ms)':<10} {'% of Total':<12} {'Min (ms)':<10} {'Max (ms)':<10}")
    print("-" * 60)

    for comp, name in zip(components, component_names):
        avg_time = df[comp].mean()
        min_time = df[comp].min()
        max_time = df[comp].max()
        percentage = (avg_time / avg_total_time * 100) if avg_total_time > 0 else 0

        print(f"{name:<8} {avg_time:<10.4f} {percentage:<12.2f} {min_time:<10.4f} {max_time:<10.4f}")


def create_performance_plots(df, output_dir="plots", suffix=""):
    """Create stacked column chart showing component performance per frame."""

    # Create output directory if it doesn't exist
    Path(output_dir).mkdir(exist_ok=True)

    # Set up the plotting style
    plt.style.use('default')
    plt.figure(figsize=(12, 8))

    # Component colors
    colors = {
        'CPU': '#4285F4',      # Blue
        'PPU': '#34A853',      # Green
        'MMIO': '#EA4335',     # Red
        'LCD': '#FBBC04',      # Yellow
        'SDL Events': '#9C27B0',   # Purple
        'Debugger': '#FF5722',     # Deep Orange
        'Interrupt': '#607D8B',    # Blue Grey
        'Other': '#795548'         # Brown
    }

    # Create stacked column chart
    frame_numbers = df['frame_number']
    cpu_times = df['cpu_time_ms']
    ppu_times = df['ppu_time_ms']
    mmio_times = df['mmio_time_ms']
    lcd_times = df['lcd_time_ms']
    sdl_times = df['sdl_events_time_ms']
    debugger_times = df['debugger_time_ms']
    interrupt_times = df['interrupt_time_ms']
    other_times = df['other_time_ms']

    # Calculate bottoms for stacking
    cpu_bottom = np.zeros(len(frame_numbers))
    ppu_bottom = cpu_times
    mmio_bottom = cpu_times + ppu_times
    lcd_bottom = cpu_times + ppu_times + mmio_times
    sdl_bottom = cpu_times + ppu_times + mmio_times + lcd_times
    debugger_bottom = cpu_times + ppu_times + mmio_times + lcd_times + sdl_times
    interrupt_bottom = cpu_times + ppu_times + mmio_times + lcd_times + sdl_times + debugger_times
    other_bottom = cpu_times + ppu_times + mmio_times + lcd_times + sdl_times + debugger_times + interrupt_times

    # Create stacked bars
    plt.bar(frame_numbers, cpu_times, bottom=cpu_bottom, color=colors['CPU'], label='CPU', alpha=0.8)
    plt.bar(frame_numbers, ppu_times, bottom=ppu_bottom, color=colors['PPU'], label='PPU', alpha=0.8)
    plt.bar(frame_numbers, mmio_times, bottom=mmio_bottom, color=colors['MMIO'], label='MMIO', alpha=0.8)
    plt.bar(frame_numbers, lcd_times, bottom=lcd_bottom, color=colors['LCD'], label='LCD', alpha=0.8)
    plt.bar(frame_numbers, sdl_times, bottom=sdl_bottom, color=colors['SDL Events'], label='SDL Events', alpha=0.8)
    plt.bar(frame_numbers, debugger_times, bottom=debugger_bottom, color=colors['Debugger'], label='Debugger', alpha=0.8)
    plt.bar(frame_numbers, interrupt_times, bottom=interrupt_bottom, color=colors['Interrupt'], label='Interrupt', alpha=0.8)
    plt.bar(frame_numbers, other_times, bottom=other_bottom, color=colors['Other'], label='Other', alpha=0.8)

    # Formatting
    plt.xlabel('Frame Number')
    plt.ylabel('Time (ms)')
    plt.title('Component Performance per Frame')
    plt.legend()
    plt.grid(True, alpha=0.3, axis='y')

    # Set integer ticks for frame numbers
    plt.xticks(frame_numbers)

    # Create filename with suffix
    filename_suffix = f"-{suffix}" if suffix else ""
    stacked_filename = f'{output_dir}/performance_stacked{filename_suffix}.png'

    plt.tight_layout()
    plt.savefig(stacked_filename, dpi=300, bbox_inches='tight')
    print(f"Saved stacked performance chart to {stacked_filename}")

    # Create pie chart showing average time distribution (excluding first frame)
    create_average_time_pie_chart(df, output_dir, suffix)

    plt.show()


def create_average_time_pie_chart(df, output_dir="plots", suffix=""):
    """Create pie chart showing average time distribution excluding first frame."""

    # Exclude first frame (frame 1) as it contains setup overhead
    df_filtered = df[df['frame_number'] > 1].copy()

    if len(df_filtered) == 0:
        print("Warning: Not enough data for pie chart (need more than 1 frame)")
        return

    print(f"Creating pie chart from {len(df_filtered)} frames (excluding first frame)")

    # Calculate average times for each component
    avg_times = {
        'CPU': df_filtered['cpu_time_ms'].mean(),
        'PPU': df_filtered['ppu_time_ms'].mean(),
        'MMIO': df_filtered['mmio_time_ms'].mean(),
        'LCD': df_filtered['lcd_time_ms'].mean(),
        'SDL Events': df_filtered['sdl_events_time_ms'].mean(),
        'Debugger': df_filtered['debugger_time_ms'].mean(),
        'Interrupt': df_filtered['interrupt_time_ms'].mean(),
        'Other': df_filtered['other_time_ms'].mean()
    }

    # Remove components with very small values (< 0.1ms average) to clean up the chart
    significant_times = {k: v for k, v in avg_times.items() if v >= 0.1}

    # Calculate total measured time vs actual frame time
    total_measured = sum(significant_times.values())
    avg_total_frame = df_filtered['total_frame_time_ms'].mean()
    unaccounted_time = avg_total_frame - total_measured

    if unaccounted_time > 0.1:
        significant_times['Unaccounted'] = unaccounted_time

    # Component colors (matching the stacked chart)
    colors_map = {
        'CPU': '#4285F4',      # Blue
        'PPU': '#34A853',      # Green
        'MMIO': '#EA4335',     # Red
        'LCD': '#FBBC04',      # Yellow
        'SDL Events': '#9C27B0',   # Purple
        'Debugger': '#FF5722',     # Deep Orange
        'Interrupt': '#607D8B',    # Blue Grey
        'Other': '#795548',        # Brown
        'Unaccounted': '#424242'   # Dark Grey
    }

    # Create pie chart
    plt.figure(figsize=(10, 8))

    labels = list(significant_times.keys())
    sizes = list(significant_times.values())
    colors = [colors_map.get(label, '#CCCCCC') for label in labels]

    # Create pie chart with percentages
    wedges, texts, autotexts = plt.pie(sizes, labels=labels, colors=colors, autopct='%1.1f%%',
                                      startangle=90, pctdistance=0.85)

    # Enhance the appearance
    plt.setp(autotexts, size=10, weight="bold")
    plt.setp(texts, size=11)

    # Add title with summary info
    plt.title(f'Average Time Distribution per Frame\n'
             f'(Excluding first frame, {len(df_filtered)} frames analyzed)\n'
             f'Average frame time: {avg_total_frame:.2f}ms',
             fontsize=14, fontweight='bold', pad=20)

    # Add a legend with actual times
    legend_labels = [f'{label}: {time:.2f}ms' for label, time in significant_times.items()]
    plt.legend(wedges, legend_labels, title="Components", loc="center left", bbox_to_anchor=(1, 0, 0.5, 1))

    # Create filename with suffix
    filename_suffix = f"-{suffix}" if suffix else ""
    pie_filename = f'{output_dir}/performance_pie_chart{filename_suffix}.png'

    plt.tight_layout()
    plt.savefig(pie_filename, dpi=300, bbox_inches='tight')
    print(f"Saved average time pie chart to {pie_filename}")


def main():
    """Main function to run the performance analyzer."""

    # Determine CSV file path and suffix
    if len(sys.argv) > 1:
        csv_path = sys.argv[1]
    else:
        csv_path = "logs/performance.csv"

    suffix = ""
    if len(sys.argv) > 2:
        suffix = sys.argv[2]

    print(f"XavBoy Performance Analyzer")
    print(f"Loading performance data from: {csv_path}")

    # Load the data
    df = load_performance_data(csv_path)
    if df is None:
        return 1

    # Validate required columns
    required_columns = ['frame_number', 'cpu_time_ms', 'ppu_time_ms',
                       'mmio_time_ms', 'lcd_time_ms', 'sdl_events_time_ms',
                       'debugger_time_ms', 'interrupt_time_ms', 'other_time_ms',
                       'total_frame_time_ms']

    missing_columns = [col for col in required_columns if col not in df.columns]
    if missing_columns:
        print(f"Error: Missing required columns in CSV: {missing_columns}")
        return 1

    # Print summary statistics
    print_summary_statistics(df)

    # Create visualizations
    print("\nGenerating performance plots...")
    if suffix:
        print(f"Using suffix: {suffix}")
    create_performance_plots(df, suffix=suffix)

    print("\nAnalysis complete!")
    return 0


if __name__ == "__main__":
    exit(main())